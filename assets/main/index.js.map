{"version":3,"sources":["../cce:/internal/rollupPluginModLoBabelHelpers.js","../file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/EnemyMgr.ts","../file:/D:/Projects/Elofun/pa-test/assets/scripts/file:/D:/Projects/Elofun/pa-test/assets/scripts/utils.ts","../file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/Gun.ts","../file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/GameMgr.ts","../file:/D:/Projects/Elofun/pa-test/assets/scripts/core/file:/D:/Projects/Elofun/pa-test/assets/scripts/core/SingletonComponent.ts","../file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/Enemy.ts","../file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/Environments.ts","../file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/NightMode.ts","../file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/ReloadUI.ts","../file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/ResultUI.ts","../file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/file:/D:/Projects/Elofun/pa-test/assets/scripts/GamePlay/Vignette.ts"],"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","_inheritsLoose","subClass","superClass","create","constructor","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_assertThisInitialized","self","ReferenceError","_initializerDefineProperty","property","context","value","initializer","call","_applyDecoratedDescriptor","decorators","desc","keys","forEach","slice","reverse","reduce","decorator","undefined","ccclass","_decorator","EnemyMgr","Node","spawnTimeMin","window","GameDefines","ENEMY_SPAWN_TIME_MIN","spawnTimeMax","ENEMY_SPAWN_TIME_MAX","spawnTime","init","node","children","child","active","destroy","update","deltaTime","min","max","GameMgr","Instance","GameState","GameStates","PLAYING","RELOADING","this","Math","random","newEnemy","instantiate","enemy","parent","setPosition","Vec3","position","y","Component","Gun","Camera","Canvas","rof","RATE_OF_FIRE","shootTimeOut","_this","ammo","AMMO","centerX","centerY","start","canvas","document","getElementById","width","height","console","log","onLoad","touchZone","on","EventType","TOUCH_MOVE","event","_this2","updateGunRotate","getDelta","dt","bulletTrail","shoot","delta","newAngleX","camera","eulerAngles","x","newAngleY","MAX_ROTATE_ANGLE","setRotationFromEuler","setState","ray","geometry","Ray","screenPointToRay","PhysicsSystem","instance","raycastClosest","raycastClosestResult","collider","hitPoint","hitNormal","distance","getComponent","Enemy","hit","GUN_DAMAGE","reload","ENEMY_HP","ENEMY_SPEED","ENEMY_COLOR","r","g","b","PARACHUTE_COLOR","SCORE_TO_WIN","TIMER","EVIRONMENT","NIGHT_MODE","VIGNETTE","END_CARD","Singleton","Label","gameState","score","timer","scoretxt","string","timerTxt","enemyMgr","gun","state","reloadUI","ingame","ingameUI","resultUI","resultUI2","END","floor","retry","addScore","onProductLink","open","name","Number","ProgressBar","healthBar","maxHP","hp","newHealthBar","healthBarPrefab","enemyColor","MeshRenderer","material","setProperty","Color","parachuteColor","parachute","z","speed","healthBarPosition","convertToUINode","worldPosition","add3f","dmg","progress","onDestroy","time","onEnable","Animation","play","TOUCH_END","completeReload","scoreTxt","Score"],"mappings":"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","file":"all.js","sourcesContent":["export { _applyDecs as applyDecs, _asyncIterator as asyncIterator, _jsx as jsx, _objectSpread2 as objectSpread2, _typeof as typeof, _wrapRegExp as wrapRegExp, _AwaitValue as AwaitValue, _AsyncGenerator as AsyncGenerator, _wrapAsyncGenerator as wrapAsyncGenerator, _awaitAsyncGenerator as awaitAsyncGenerator, _asyncGeneratorDelegate as asyncGeneratorDelegate, _asyncToGenerator as asyncToGenerator, _classCallCheck as classCallCheck, _createClass as createClass, _defineEnumerableProperties as defineEnumerableProperties, _defaults as defaults, _defineProperty as defineProperty, _extends as extends, _objectSpread as objectSpread, _inherits as inherits, _inheritsLoose as inheritsLoose, _getPrototypeOf as getPrototypeOf, _setPrototypeOf as setPrototypeOf, _isNativeReflectConstruct as isNativeReflectConstruct, _construct as construct, _isNativeFunction as isNativeFunction, _wrapNativeSuper as wrapNativeSuper, _instanceof as instanceof, _interopRequireDefault as interopRequireDefault, _interopRequireWildcard as interopRequireWildcard, _newArrowCheck as newArrowCheck, _objectDestructuringEmpty as objectDestructuringEmpty, _objectWithoutPropertiesLoose as objectWithoutPropertiesLoose, _objectWithoutProperties as objectWithoutProperties, _assertThisInitialized as assertThisInitialized, _possibleConstructorReturn as possibleConstructorReturn, _createSuper as createSuper, _superPropBase as superPropBase, _get as get, _set as set, _taggedTemplateLiteral as taggedTemplateLiteral, _taggedTemplateLiteralLoose as taggedTemplateLiteralLoose, _readOnlyError as readOnlyError, _writeOnlyError as writeOnlyError, _classNameTDZError as classNameTDZError, _temporalUndefined as temporalUndefined, _tdz as tdz, _temporalRef as temporalRef, _slicedToArray as slicedToArray, _slicedToArrayLoose as slicedToArrayLoose, _toArray as toArray, _toConsumableArray as toConsumableArray, _arrayWithoutHoles as arrayWithoutHoles, _arrayWithHoles as arrayWithHoles, _maybeArrayLike as maybeArrayLike, _iterableToArray as iterableToArray, _iterableToArrayLimit as iterableToArrayLimit, _iterableToArrayLimitLoose as iterableToArrayLimitLoose, _unsupportedIterableToArray as unsupportedIterableToArray, _arrayLikeToArray as arrayLikeToArray, _nonIterableSpread as nonIterableSpread, _nonIterableRest as nonIterableRest, _createForOfIteratorHelper as createForOfIteratorHelper, _createForOfIteratorHelperLoose as createForOfIteratorHelperLoose, _skipFirstGeneratorNext as skipFirstGeneratorNext, _toPrimitive as toPrimitive, _toPropertyKey as toPropertyKey, _initializerWarningHelper as initializerWarningHelper, _initializerDefineProperty as initializerDefineProperty, _applyDecoratedDescriptor as applyDecoratedDescriptor, _classPrivateFieldLooseKey as classPrivateFieldLooseKey, _classPrivateFieldLooseBase as classPrivateFieldLooseBase, _classPrivateFieldGet as classPrivateFieldGet, _classPrivateFieldSet as classPrivateFieldSet, _classPrivateFieldDestructureSet as classPrivateFieldDestructureSet, _classExtractFieldDescriptor as classExtractFieldDescriptor, _classStaticPrivateFieldSpecGet as classStaticPrivateFieldSpecGet, _classStaticPrivateFieldSpecSet as classStaticPrivateFieldSpecSet, _classStaticPrivateMethodGet as classStaticPrivateMethodGet, _classStaticPrivateMethodSet as classStaticPrivateMethodSet, _classApplyDescriptorGet as classApplyDescriptorGet, _classApplyDescriptorSet as classApplyDescriptorSet, _classApplyDescriptorDestructureSet as classApplyDescriptorDestructureSet, _classStaticPrivateFieldDestructureSet as classStaticPrivateFieldDestructureSet, _classCheckPrivateStaticAccess as classCheckPrivateStaticAccess, _classCheckPrivateStaticFieldDescriptor as classCheckPrivateStaticFieldDescriptor, _decorate as decorate, _classPrivateMethodGet as classPrivateMethodGet, _checkPrivateRedeclaration as checkPrivateRedeclaration, _classPrivateFieldInitSpec as classPrivateFieldInitSpec, _classPrivateMethodInitSpec as classPrivateMethodInitSpec, _classPrivateMethodSet as classPrivateMethodSet, _identity as identity };\n\nfunction createMetadataMethodsForProperty(metadataMap, kind, property, decoratorFinishedRef) {\n  return {\n    getMetadata: function (key) {\n      assertNotFinished(decoratorFinishedRef, \"getMetadata\"), assertMetadataKey(key);\n      var metadataForKey = metadataMap[key];\n      if (void 0 !== metadataForKey) if (1 === kind) {\n        var pub = metadataForKey.public;\n        if (void 0 !== pub) return pub[property];\n      } else if (2 === kind) {\n        var priv = metadataForKey.private;\n        if (void 0 !== priv) return priv.get(property);\n      } else if (Object.hasOwnProperty.call(metadataForKey, \"constructor\")) return metadataForKey.constructor;\n    },\n    setMetadata: function (key, value) {\n      assertNotFinished(decoratorFinishedRef, \"setMetadata\"), assertMetadataKey(key);\n      var metadataForKey = metadataMap[key];\n\n      if (void 0 === metadataForKey && (metadataForKey = metadataMap[key] = {}), 1 === kind) {\n        var pub = metadataForKey.public;\n        void 0 === pub && (pub = metadataForKey.public = {}), pub[property] = value;\n      } else if (2 === kind) {\n        var priv = metadataForKey.priv;\n        void 0 === priv && (priv = metadataForKey.private = new Map()), priv.set(property, value);\n      } else metadataForKey.constructor = value;\n    }\n  };\n}\n\nfunction convertMetadataMapToFinal(obj, metadataMap) {\n  var parentMetadataMap = obj[Symbol.metadata || Symbol.for(\"Symbol.metadata\")],\n      metadataKeys = Object.getOwnPropertySymbols(metadataMap);\n\n  if (0 !== metadataKeys.length) {\n    for (var i = 0; i < metadataKeys.length; i++) {\n      var key = metadataKeys[i],\n          metaForKey = metadataMap[key],\n          parentMetaForKey = parentMetadataMap ? parentMetadataMap[key] : null,\n          pub = metaForKey.public,\n          parentPub = parentMetaForKey ? parentMetaForKey.public : null;\n      pub && parentPub && Object.setPrototypeOf(pub, parentPub);\n      var priv = metaForKey.private;\n\n      if (priv) {\n        var privArr = Array.from(priv.values()),\n            parentPriv = parentMetaForKey ? parentMetaForKey.private : null;\n        parentPriv && (privArr = privArr.concat(parentPriv)), metaForKey.private = privArr;\n      }\n\n      parentMetaForKey && Object.setPrototypeOf(metaForKey, parentMetaForKey);\n    }\n\n    parentMetadataMap && Object.setPrototypeOf(metadataMap, parentMetadataMap), obj[Symbol.metadata || Symbol.for(\"Symbol.metadata\")] = metadataMap;\n  }\n}\n\nfunction createAddInitializerMethod(initializers, decoratorFinishedRef) {\n  return function (initializer) {\n    assertNotFinished(decoratorFinishedRef, \"addInitializer\"), assertCallable(initializer, \"An initializer\"), initializers.push(initializer);\n  };\n}\n\nfunction memberDec(dec, name, desc, metadataMap, initializers, kind, isStatic, isPrivate, value) {\n  var kindStr;\n\n  switch (kind) {\n    case 1:\n      kindStr = \"accessor\";\n      break;\n\n    case 2:\n      kindStr = \"method\";\n      break;\n\n    case 3:\n      kindStr = \"getter\";\n      break;\n\n    case 4:\n      kindStr = \"setter\";\n      break;\n\n    default:\n      kindStr = \"field\";\n  }\n\n  var metadataKind,\n      metadataName,\n      ctx = {\n    kind: kindStr,\n    name: isPrivate ? \"#\" + name : name,\n    isStatic: isStatic,\n    isPrivate: isPrivate\n  },\n      decoratorFinishedRef = {\n    v: !1\n  };\n\n  if (0 !== kind && (ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef)), isPrivate) {\n    metadataKind = 2, metadataName = Symbol(name);\n    var access = {};\n    0 === kind ? (access.get = desc.get, access.set = desc.set) : 2 === kind ? access.get = function () {\n      return desc.value;\n    } : (1 !== kind && 3 !== kind || (access.get = function () {\n      return desc.get.call(this);\n    }), 1 !== kind && 4 !== kind || (access.set = function (v) {\n      desc.set.call(this, v);\n    })), ctx.access = access;\n  } else metadataKind = 1, metadataName = name;\n\n  try {\n    return dec(value, Object.assign(ctx, createMetadataMethodsForProperty(metadataMap, metadataKind, metadataName, decoratorFinishedRef)));\n  } finally {\n    decoratorFinishedRef.v = !0;\n  }\n}\n\nfunction assertNotFinished(decoratorFinishedRef, fnName) {\n  if (decoratorFinishedRef.v) throw new Error(\"attempted to call \" + fnName + \" after decoration was finished\");\n}\n\nfunction assertMetadataKey(key) {\n  if (\"symbol\" != typeof key) throw new TypeError(\"Metadata keys must be symbols, received: \" + key);\n}\n\nfunction assertCallable(fn, hint) {\n  if (\"function\" != typeof fn) throw new TypeError(hint + \" must be a function\");\n}\n\nfunction assertValidReturnValue(kind, value) {\n  var type = typeof value;\n\n  if (1 === kind) {\n    if (\"object\" !== type || null === value) throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");\n    void 0 !== value.get && assertCallable(value.get, \"accessor.get\"), void 0 !== value.set && assertCallable(value.set, \"accessor.set\"), void 0 !== value.init && assertCallable(value.init, \"accessor.init\"), void 0 !== value.initializer && assertCallable(value.initializer, \"accessor.initializer\");\n  } else if (\"function\" !== type) {\n    var hint;\n    throw hint = 0 === kind ? \"field\" : 10 === kind ? \"class\" : \"method\", new TypeError(hint + \" decorators must return a function or void 0\");\n  }\n}\n\nfunction getInit(desc) {\n  var initializer;\n  return null == (initializer = desc.init) && (initializer = desc.initializer) && \"undefined\" != typeof console && console.warn(\".initializer has been renamed to .init as of March 2022\"), initializer;\n}\n\nfunction applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers) {\n  var desc,\n      initializer,\n      value,\n      newValue,\n      get,\n      set,\n      decs = decInfo[0];\n  if (isPrivate ? desc = 0 === kind || 1 === kind ? {\n    get: decInfo[3],\n    set: decInfo[4]\n  } : 3 === kind ? {\n    get: decInfo[3]\n  } : 4 === kind ? {\n    set: decInfo[3]\n  } : {\n    value: decInfo[3]\n  } : 0 !== kind && (desc = Object.getOwnPropertyDescriptor(base, name)), 1 === kind ? value = {\n    get: desc.get,\n    set: desc.set\n  } : 2 === kind ? value = desc.value : 3 === kind ? value = desc.get : 4 === kind && (value = desc.set), \"function\" == typeof decs) void 0 !== (newValue = memberDec(decs, name, desc, metadataMap, initializers, kind, isStatic, isPrivate, value)) && (assertValidReturnValue(kind, newValue), 0 === kind ? initializer = newValue : 1 === kind ? (initializer = getInit(newValue), get = newValue.get || value.get, set = newValue.set || value.set, value = {\n    get: get,\n    set: set\n  }) : value = newValue);else for (var i = decs.length - 1; i >= 0; i--) {\n    var newInit;\n    if (void 0 !== (newValue = memberDec(decs[i], name, desc, metadataMap, initializers, kind, isStatic, isPrivate, value))) assertValidReturnValue(kind, newValue), 0 === kind ? newInit = newValue : 1 === kind ? (newInit = getInit(newValue), get = newValue.get || value.get, set = newValue.set || value.set, value = {\n      get: get,\n      set: set\n    }) : value = newValue, void 0 !== newInit && (void 0 === initializer ? initializer = newInit : \"function\" == typeof initializer ? initializer = [initializer, newInit] : initializer.push(newInit));\n  }\n\n  if (0 === kind || 1 === kind) {\n    if (void 0 === initializer) initializer = function (instance, init) {\n      return init;\n    };else if (\"function\" != typeof initializer) {\n      var ownInitializers = initializer;\n\n      initializer = function (instance, init) {\n        for (var value = init, i = 0; i < ownInitializers.length; i++) value = ownInitializers[i].call(instance, value);\n\n        return value;\n      };\n    } else {\n      var originalInitializer = initializer;\n\n      initializer = function (instance, init) {\n        return originalInitializer.call(instance, init);\n      };\n    }\n    ret.push(initializer);\n  }\n\n  0 !== kind && (1 === kind ? (desc.get = value.get, desc.set = value.set) : 2 === kind ? desc.value = value : 3 === kind ? desc.get = value : 4 === kind && (desc.set = value), isPrivate ? 1 === kind ? (ret.push(function (instance, args) {\n    return value.get.call(instance, args);\n  }), ret.push(function (instance, args) {\n    return value.set.call(instance, args);\n  })) : 2 === kind ? ret.push(value) : ret.push(function (instance, args) {\n    return value.call(instance, args);\n  }) : Object.defineProperty(base, name, desc));\n}\n\nfunction applyMemberDecs(ret, Class, protoMetadataMap, staticMetadataMap, decInfos) {\n  for (var protoInitializers, staticInitializers, existingProtoNonFields = new Map(), existingStaticNonFields = new Map(), i = 0; i < decInfos.length; i++) {\n    var decInfo = decInfos[i];\n\n    if (Array.isArray(decInfo)) {\n      var base,\n          metadataMap,\n          initializers,\n          kind = decInfo[1],\n          name = decInfo[2],\n          isPrivate = decInfo.length > 3,\n          isStatic = kind >= 5;\n\n      if (isStatic ? (base = Class, metadataMap = staticMetadataMap, 0 !== (kind -= 5) && (initializers = staticInitializers = staticInitializers || [])) : (base = Class.prototype, metadataMap = protoMetadataMap, 0 !== kind && (initializers = protoInitializers = protoInitializers || [])), 0 !== kind && !isPrivate) {\n        var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields,\n            existingKind = existingNonFields.get(name) || 0;\n        if (!0 === existingKind || 3 === existingKind && 4 !== kind || 4 === existingKind && 3 !== kind) throw new Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \" + name);\n        !existingKind && kind > 2 ? existingNonFields.set(name, kind) : existingNonFields.set(name, !0);\n      }\n\n      applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers);\n    }\n  }\n\n  pushInitializers(ret, protoInitializers), pushInitializers(ret, staticInitializers);\n}\n\nfunction pushInitializers(ret, initializers) {\n  initializers && ret.push(function (instance) {\n    for (var i = 0; i < initializers.length; i++) initializers[i].call(instance);\n\n    return instance;\n  });\n}\n\nfunction applyClassDecs(ret, targetClass, metadataMap, classDecs) {\n  if (classDecs.length > 0) {\n    for (var initializers = [], newClass = targetClass, name = targetClass.name, i = classDecs.length - 1; i >= 0; i--) {\n      var decoratorFinishedRef = {\n        v: !1\n      };\n\n      try {\n        var ctx = Object.assign({\n          kind: \"class\",\n          name: name,\n          addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef)\n        }, createMetadataMethodsForProperty(metadataMap, 0, name, decoratorFinishedRef)),\n            nextNewClass = classDecs[i](newClass, ctx);\n      } finally {\n        decoratorFinishedRef.v = !0;\n      }\n\n      void 0 !== nextNewClass && (assertValidReturnValue(10, nextNewClass), newClass = nextNewClass);\n    }\n\n    ret.push(newClass, function () {\n      for (var i = 0; i < initializers.length; i++) initializers[i].call(newClass);\n    });\n  }\n}\n\nfunction _applyDecs(targetClass, memberDecs, classDecs) {\n  var ret = [],\n      staticMetadataMap = {},\n      protoMetadataMap = {};\n  return applyMemberDecs(ret, targetClass, protoMetadataMap, staticMetadataMap, memberDecs), convertMetadataMapToFinal(targetClass.prototype, protoMetadataMap), applyClassDecs(ret, targetClass, staticMetadataMap, classDecs), convertMetadataMapToFinal(targetClass, staticMetadataMap), ret;\n}\n\nfunction _asyncIterator(iterable) {\n  var method,\n      async,\n      sync,\n      retry = 2;\n\n  for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {\n    if (async && null != (method = iterable[async])) return method.call(iterable);\n    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));\n    async = \"@@asyncIterator\", sync = \"@@iterator\";\n  }\n\n  throw new TypeError(\"Object is not async iterable\");\n}\n\nfunction AsyncFromSyncIterator(s) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var done = r.done;\n    return Promise.resolve(r.value).then(function (value) {\n      return {\n        value: value,\n        done: done\n      };\n    });\n  }\n\n  return AsyncFromSyncIterator = function (s) {\n    this.s = s, this.n = s.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function () {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    return: function (value) {\n      var ret = this.s.return;\n      return void 0 === ret ? Promise.resolve({\n        value: value,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));\n    },\n    throw: function (value) {\n      var thr = this.s.return;\n      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(s);\n}\n\nvar REACT_ELEMENT_TYPE;\n\nfunction _jsx(type, props, key, children) {\n  REACT_ELEMENT_TYPE || (REACT_ELEMENT_TYPE = \"function\" == typeof Symbol && Symbol.for && Symbol.for(\"react.element\") || 60103);\n  var defaultProps = type && type.defaultProps,\n      childrenLength = arguments.length - 3;\n  if (props || 0 === childrenLength || (props = {\n    children: void 0\n  }), 1 === childrenLength) props.children = children;else if (childrenLength > 1) {\n    for (var childArray = new Array(childrenLength), i = 0; i < childrenLength; i++) childArray[i] = arguments[i + 3];\n\n    props.children = childArray;\n  }\n  if (props && defaultProps) for (var propName in defaultProps) void 0 === props[propName] && (props[propName] = defaultProps[propName]);else props || (props = defaultProps || {});\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: void 0 === key ? null : \"\" + key,\n    ref: null,\n    props: props,\n    _owner: null\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _wrapRegExp() {\n  _wrapRegExp = function (re, groups) {\n    return new BabelRegExp(re, void 0, groups);\n  };\n\n  var _super = RegExp.prototype,\n      _groups = new WeakMap();\n\n  function BabelRegExp(re, flags, groups) {\n    var _this = new RegExp(re, flags);\n\n    return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);\n  }\n\n  function buildGroups(result, re) {\n    var g = _groups.get(re);\n\n    return Object.keys(g).reduce(function (groups, name) {\n      return groups[name] = result[g[name]], groups;\n    }, Object.create(null));\n  }\n\n  return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {\n    var result = _super.exec.call(this, str);\n\n    return result && (result.groups = buildGroups(result, this)), result;\n  }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {\n    if (\"string\" == typeof substitution) {\n      var groups = _groups.get(this);\n\n      return _super[Symbol.replace].call(this, str, substitution.replace(/\\$<([^>]+)>/g, function (_, name) {\n        return \"$\" + groups[name];\n      }));\n    }\n\n    if (\"function\" == typeof substitution) {\n      var _this = this;\n\n      return _super[Symbol.replace].call(this, str, function () {\n        var args = arguments;\n        return \"object\" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);\n      });\n    }\n\n    return _super[Symbol.replace].call(this, str, substitution);\n  }, _wrapRegExp.apply(this, arguments);\n}\n\nfunction _AwaitValue(value) {\n  this.wrapped = value;\n}\n\nfunction _AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof _AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(key === \"return\" ? \"return\" : \"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen.return !== \"function\") {\n    this.return = undefined;\n  }\n}\n\n_AsyncGenerator.prototype[typeof Symbol === \"function\" && Symbol.asyncIterator || \"@@asyncIterator\"] = function () {\n  return this;\n};\n\n_AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\n_AsyncGenerator.prototype.throw = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\n_AsyncGenerator.prototype.return = function (arg) {\n  return this._invoke(\"return\", arg);\n};\n\nfunction _wrapAsyncGenerator(fn) {\n  return function () {\n    return new _AsyncGenerator(fn.apply(this, arguments));\n  };\n}\n\nfunction _awaitAsyncGenerator(value) {\n  return new _AwaitValue(value);\n}\n\nfunction _asyncGeneratorDelegate(inner, awaitWrap) {\n  var iter = {},\n      waiting = false;\n\n  function pump(key, value) {\n    waiting = true;\n    value = new Promise(function (resolve) {\n      resolve(inner[key](value));\n    });\n    return {\n      done: false,\n      value: awaitWrap(value)\n    };\n  }\n\n  ;\n\n  iter[typeof Symbol !== \"undefined\" && Symbol.iterator || \"@@iterator\"] = function () {\n    return this;\n  };\n\n  iter.next = function (value) {\n    if (waiting) {\n      waiting = false;\n      return value;\n    }\n\n    return pump(\"next\", value);\n  };\n\n  if (typeof inner.throw === \"function\") {\n    iter.throw = function (value) {\n      if (waiting) {\n        waiting = false;\n        throw value;\n      }\n\n      return pump(\"throw\", value);\n    };\n  }\n\n  if (typeof inner.return === \"function\") {\n    iter.return = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n\n      return pump(\"return\", value);\n    };\n  }\n\n  return iter;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _defineEnumerableProperties(obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    var objectSymbols = Object.getOwnPropertySymbols(descs);\n\n    for (var i = 0; i < objectSymbols.length; i++) {\n      var sym = objectSymbols[i];\n      var desc = descs[sym];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, sym, desc);\n    }\n  }\n\n  return obj;\n}\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return !!right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _newArrowCheck(innerThis, boundThis) {\n  if (innerThis !== boundThis) {\n    throw new TypeError(\"Cannot instantiate an arrow function\");\n  }\n}\n\nfunction _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get.apply(this, arguments);\n}\n\nfunction set(target, property, value, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.set) {\n    set = Reflect.set;\n  } else {\n    set = function set(target, property, value, receiver) {\n      var base = _superPropBase(target, property);\n\n      var desc;\n\n      if (base) {\n        desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.set) {\n          desc.set.call(receiver, value);\n          return true;\n        } else if (!desc.writable) {\n          return false;\n        }\n      }\n\n      desc = Object.getOwnPropertyDescriptor(receiver, property);\n\n      if (desc) {\n        if (!desc.writable) {\n          return false;\n        }\n\n        desc.value = value;\n        Object.defineProperty(receiver, property, desc);\n      } else {\n        _defineProperty(receiver, property, value);\n      }\n\n      return true;\n    };\n  }\n\n  return set(target, property, value, receiver);\n}\n\nfunction _set(target, property, value, receiver, isStrict) {\n  var s = set(target, property, value, receiver || target);\n\n  if (!s && isStrict) {\n    throw new Error('failed to set property');\n  }\n\n  return value;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  strings.raw = raw;\n  return strings;\n}\n\nfunction _readOnlyError(name) {\n  throw new TypeError(\"\\\"\" + name + \"\\\" is read-only\");\n}\n\nfunction _writeOnlyError(name) {\n  throw new TypeError(\"\\\"\" + name + \"\\\" is write-only\");\n}\n\nfunction _classNameTDZError(name) {\n  throw new Error(\"Class \\\"\" + name + \"\\\" cannot be referenced in computed property keys.\");\n}\n\nfunction _temporalUndefined() {}\n\nfunction _tdz(name) {\n  throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n}\n\nfunction _temporalRef(val, name) {\n  return val === _temporalUndefined ? _tdz(name) : val;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _slicedToArrayLoose(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimitLoose(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _maybeArrayLike(next, arr, i) {\n  if (arr && !Array.isArray(arr) && typeof arr.length === \"number\") {\n    var len = arr.length;\n    return _arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);\n  }\n\n  return next(arr, i);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _iterableToArrayLimitLoose(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n\n  for (_i = _i.call(arr), _step; !(_step = _i.next()).done;) {\n    _arr.push(_step.value);\n\n    if (i && _arr.length === i) break;\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _skipFirstGeneratorNext(fn) {\n  return function () {\n    var it = fn.apply(this, arguments);\n    it.next();\n    return it;\n  };\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _initializerWarningHelper(descriptor, context) {\n  throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.');\n}\n\nfunction _initializerDefineProperty(target, property, descriptor, context) {\n  if (!descriptor) return;\n  Object.defineProperty(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object.keys(descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object.defineProperty(target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nvar id = 0;\n\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\n\nfunction _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n\n  return receiver;\n}\n\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n\n  _classApplyDescriptorSet(receiver, descriptor, value);\n\n  return value;\n}\n\nfunction _classPrivateFieldDestructureSet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n\n  return _classApplyDescriptorDestructureSet(receiver, descriptor);\n}\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\n\nfunction _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\n\n  _classCheckPrivateStaticFieldDescriptor(descriptor, \"get\");\n\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\n\nfunction _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\n\n  _classCheckPrivateStaticFieldDescriptor(descriptor, \"set\");\n\n  _classApplyDescriptorSet(receiver, descriptor, value);\n\n  return value;\n}\n\nfunction _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\n\n  return method;\n}\n\nfunction _classStaticPrivateMethodSet() {\n  throw new TypeError(\"attempted to set read only static private field\");\n}\n\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n\n  return descriptor.value;\n}\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n\n    descriptor.value = value;\n  }\n}\n\nfunction _classApplyDescriptorDestructureSet(receiver, descriptor) {\n  if (descriptor.set) {\n    if (!(\"__destrObj\" in descriptor)) {\n      descriptor.__destrObj = {\n        set value(v) {\n          descriptor.set.call(receiver, v);\n        }\n\n      };\n    }\n\n    return descriptor.__destrObj;\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n\n    return descriptor;\n  }\n}\n\nfunction _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\n\n  _classCheckPrivateStaticFieldDescriptor(descriptor, \"set\");\n\n  return _classApplyDescriptorDestructureSet(receiver, descriptor);\n}\n\nfunction _classCheckPrivateStaticAccess(receiver, classConstructor) {\n  if (receiver !== classConstructor) {\n    throw new TypeError(\"Private static access of wrong provenance\");\n  }\n}\n\nfunction _classCheckPrivateStaticFieldDescriptor(descriptor, action) {\n  if (descriptor === undefined) {\n    throw new TypeError(\"attempted to \" + action + \" private static field before its declaration\");\n  }\n}\n\nfunction _decorate(decorators, factory, superClass, mixins) {\n  var api = _getDecoratorsApi();\n\n  if (mixins) {\n    for (var i = 0; i < mixins.length; i++) {\n      api = mixins[i](api);\n    }\n  }\n\n  var r = factory(function initialize(O) {\n    api.initializeInstanceElements(O, decorated.elements);\n  }, superClass);\n  var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators);\n  api.initializeClassElements(r.F, decorated.elements);\n  return api.runClassFinishers(r.F, decorated.finishers);\n}\n\nfunction _getDecoratorsApi() {\n  _getDecoratorsApi = function () {\n    return api;\n  };\n\n  var api = {\n    elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n    initializeInstanceElements: function (O, elements) {\n      [\"method\", \"field\"].forEach(function (kind) {\n        elements.forEach(function (element) {\n          if (element.kind === kind && element.placement === \"own\") {\n            this.defineClassElement(O, element);\n          }\n        }, this);\n      }, this);\n    },\n    initializeClassElements: function (F, elements) {\n      var proto = F.prototype;\n      [\"method\", \"field\"].forEach(function (kind) {\n        elements.forEach(function (element) {\n          var placement = element.placement;\n\n          if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) {\n            var receiver = placement === \"static\" ? F : proto;\n            this.defineClassElement(receiver, element);\n          }\n        }, this);\n      }, this);\n    },\n    defineClassElement: function (receiver, element) {\n      var descriptor = element.descriptor;\n\n      if (element.kind === \"field\") {\n        var initializer = element.initializer;\n        descriptor = {\n          enumerable: descriptor.enumerable,\n          writable: descriptor.writable,\n          configurable: descriptor.configurable,\n          value: initializer === void 0 ? void 0 : initializer.call(receiver)\n        };\n      }\n\n      Object.defineProperty(receiver, element.key, descriptor);\n    },\n    decorateClass: function (elements, decorators) {\n      var newElements = [];\n      var finishers = [];\n      var placements = {\n        static: [],\n        prototype: [],\n        own: []\n      };\n      elements.forEach(function (element) {\n        this.addElementPlacement(element, placements);\n      }, this);\n      elements.forEach(function (element) {\n        if (!_hasDecorators(element)) return newElements.push(element);\n        var elementFinishersExtras = this.decorateElement(element, placements);\n        newElements.push(elementFinishersExtras.element);\n        newElements.push.apply(newElements, elementFinishersExtras.extras);\n        finishers.push.apply(finishers, elementFinishersExtras.finishers);\n      }, this);\n\n      if (!decorators) {\n        return {\n          elements: newElements,\n          finishers: finishers\n        };\n      }\n\n      var result = this.decorateConstructor(newElements, decorators);\n      finishers.push.apply(finishers, result.finishers);\n      result.finishers = finishers;\n      return result;\n    },\n    addElementPlacement: function (element, placements, silent) {\n      var keys = placements[element.placement];\n\n      if (!silent && keys.indexOf(element.key) !== -1) {\n        throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n      }\n\n      keys.push(element.key);\n    },\n    decorateElement: function (element, placements) {\n      var extras = [];\n      var finishers = [];\n\n      for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {\n        var keys = placements[element.placement];\n        keys.splice(keys.indexOf(element.key), 1);\n        var elementObject = this.fromElementDescriptor(element);\n        var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject);\n        element = elementFinisherExtras.element;\n        this.addElementPlacement(element, placements);\n\n        if (elementFinisherExtras.finisher) {\n          finishers.push(elementFinisherExtras.finisher);\n        }\n\n        var newExtras = elementFinisherExtras.extras;\n\n        if (newExtras) {\n          for (var j = 0; j < newExtras.length; j++) {\n            this.addElementPlacement(newExtras[j], placements);\n          }\n\n          extras.push.apply(extras, newExtras);\n        }\n      }\n\n      return {\n        element: element,\n        finishers: finishers,\n        extras: extras\n      };\n    },\n    decorateConstructor: function (elements, decorators) {\n      var finishers = [];\n\n      for (var i = decorators.length - 1; i >= 0; i--) {\n        var obj = this.fromClassDescriptor(elements);\n        var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj);\n\n        if (elementsAndFinisher.finisher !== undefined) {\n          finishers.push(elementsAndFinisher.finisher);\n        }\n\n        if (elementsAndFinisher.elements !== undefined) {\n          elements = elementsAndFinisher.elements;\n\n          for (var j = 0; j < elements.length - 1; j++) {\n            for (var k = j + 1; k < elements.length; k++) {\n              if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) {\n                throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\");\n              }\n            }\n          }\n        }\n      }\n\n      return {\n        elements: elements,\n        finishers: finishers\n      };\n    },\n    fromElementDescriptor: function (element) {\n      var obj = {\n        kind: element.kind,\n        key: element.key,\n        placement: element.placement,\n        descriptor: element.descriptor\n      };\n      var desc = {\n        value: \"Descriptor\",\n        configurable: true\n      };\n      Object.defineProperty(obj, Symbol.toStringTag, desc);\n      if (element.kind === \"field\") obj.initializer = element.initializer;\n      return obj;\n    },\n    toElementDescriptors: function (elementObjects) {\n      if (elementObjects === undefined) return;\n      return _toArray(elementObjects).map(function (elementObject) {\n        var element = this.toElementDescriptor(elementObject);\n        this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n        this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n        return element;\n      }, this);\n    },\n    toElementDescriptor: function (elementObject) {\n      var kind = String(elementObject.kind);\n\n      if (kind !== \"method\" && kind !== \"field\") {\n        throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"');\n      }\n\n      var key = _toPropertyKey(elementObject.key);\n\n      var placement = String(elementObject.placement);\n\n      if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") {\n        throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"');\n      }\n\n      var descriptor = elementObject.descriptor;\n      this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n      var element = {\n        kind: kind,\n        key: key,\n        placement: placement,\n        descriptor: Object.assign({}, descriptor)\n      };\n\n      if (kind !== \"field\") {\n        this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n      } else {\n        this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\");\n        this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\");\n        this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\");\n        element.initializer = elementObject.initializer;\n      }\n\n      return element;\n    },\n    toElementFinisherExtras: function (elementObject) {\n      var element = this.toElementDescriptor(elementObject);\n\n      var finisher = _optionalCallableProperty(elementObject, \"finisher\");\n\n      var extras = this.toElementDescriptors(elementObject.extras);\n      return {\n        element: element,\n        finisher: finisher,\n        extras: extras\n      };\n    },\n    fromClassDescriptor: function (elements) {\n      var obj = {\n        kind: \"class\",\n        elements: elements.map(this.fromElementDescriptor, this)\n      };\n      var desc = {\n        value: \"Descriptor\",\n        configurable: true\n      };\n      Object.defineProperty(obj, Symbol.toStringTag, desc);\n      return obj;\n    },\n    toClassDescriptor: function (obj) {\n      var kind = String(obj.kind);\n\n      if (kind !== \"class\") {\n        throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"');\n      }\n\n      this.disallowProperty(obj, \"key\", \"A class descriptor\");\n      this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n      this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n      this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n      this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n      var finisher = _optionalCallableProperty(obj, \"finisher\");\n\n      var elements = this.toElementDescriptors(obj.elements);\n      return {\n        elements: elements,\n        finisher: finisher\n      };\n    },\n    runClassFinishers: function (constructor, finishers) {\n      for (var i = 0; i < finishers.length; i++) {\n        var newConstructor = (0, finishers[i])(constructor);\n\n        if (newConstructor !== undefined) {\n          if (typeof newConstructor !== \"function\") {\n            throw new TypeError(\"Finishers must return a constructor.\");\n          }\n\n          constructor = newConstructor;\n        }\n      }\n\n      return constructor;\n    },\n    disallowProperty: function (obj, name, objectType) {\n      if (obj[name] !== undefined) {\n        throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n      }\n    }\n  };\n  return api;\n}\n\nfunction _createElementDescriptor(def) {\n  var key = _toPropertyKey(def.key);\n\n  var descriptor;\n\n  if (def.kind === \"method\") {\n    descriptor = {\n      value: def.value,\n      writable: true,\n      configurable: true,\n      enumerable: false\n    };\n  } else if (def.kind === \"get\") {\n    descriptor = {\n      get: def.value,\n      configurable: true,\n      enumerable: false\n    };\n  } else if (def.kind === \"set\") {\n    descriptor = {\n      set: def.value,\n      configurable: true,\n      enumerable: false\n    };\n  } else if (def.kind === \"field\") {\n    descriptor = {\n      configurable: true,\n      writable: true,\n      enumerable: true\n    };\n  }\n\n  var element = {\n    kind: def.kind === \"field\" ? \"field\" : \"method\",\n    key: key,\n    placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\",\n    descriptor: descriptor\n  };\n  if (def.decorators) element.decorators = def.decorators;\n  if (def.kind === \"field\") element.initializer = def.value;\n  return element;\n}\n\nfunction _coalesceGetterSetter(element, other) {\n  if (element.descriptor.get !== undefined) {\n    other.descriptor.get = element.descriptor.get;\n  } else {\n    other.descriptor.set = element.descriptor.set;\n  }\n}\n\nfunction _coalesceClassElements(elements) {\n  var newElements = [];\n\n  var isSameElement = function (other) {\n    return other.kind === \"method\" && other.key === element.key && other.placement === element.placement;\n  };\n\n  for (var i = 0; i < elements.length; i++) {\n    var element = elements[i];\n    var other;\n\n    if (element.kind === \"method\" && (other = newElements.find(isSameElement))) {\n      if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {\n        if (_hasDecorators(element) || _hasDecorators(other)) {\n          throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\");\n        }\n\n        other.descriptor = element.descriptor;\n      } else {\n        if (_hasDecorators(element)) {\n          if (_hasDecorators(other)) {\n            throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\");\n          }\n\n          other.decorators = element.decorators;\n        }\n\n        _coalesceGetterSetter(element, other);\n      }\n    } else {\n      newElements.push(element);\n    }\n  }\n\n  return newElements;\n}\n\nfunction _hasDecorators(element) {\n  return element.decorators && element.decorators.length;\n}\n\nfunction _isDataDescriptor(desc) {\n  return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);\n}\n\nfunction _optionalCallableProperty(obj, name) {\n  var value = obj[name];\n\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n  }\n\n  return value;\n}\n\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return fn;\n}\n\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\n\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n\n  privateMap.set(obj, value);\n}\n\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n\n  privateSet.add(obj);\n}\n\nfunction _classPrivateMethodSet() {\n  throw new TypeError(\"attempted to reassign private method\");\n}\n\nfunction _identity(x) {\n  return x;\n}","import { _decorator, Component, instantiate, Node, Vec3 } from 'cc';\nimport { Rand } from '../utils';\nimport { GameMgr, GameStates } from './GameMgr';\nconst { ccclass, property } = _decorator;\n\n@ccclass('EnemyMgr')\nexport class EnemyMgr extends Component {\n    @property(Node)\n    public enemy: Node = null;\n\n    private spawnTimeMin = (window as any).GameDefines.ENEMY_SPAWN_TIME_MIN;\n    private spawnTimeMax = (window as any).GameDefines.ENEMY_SPAWN_TIME_MAX;\n    private spawnTime = (window as any).GameDefines.ENEMY_SPAWN_TIME_MAX;\n\n    init() {\n        this.node.children.forEach((child) => {\n            if (child.active) {\n                child.destroy();\n            }\n        })\n    }\n\n    update(deltaTime: number) {\n        if (GameMgr.Instance.GameState !== GameStates.PLAYING && GameMgr.Instance.GameState !== GameStates.RELOADING) return;\n\n        this.spawnTime -= deltaTime;\n\n        if (this.spawnTime < 0) {\n            this.spawnTime = Rand(this.spawnTimeMin, this.spawnTimeMax);\n            const newEnemy = instantiate(this.enemy);\n            newEnemy.parent = this.node;\n            newEnemy.active = true;\n            newEnemy.setPosition(new Vec3((Math.random() - 0.5) * 10, newEnemy.position.y));\n        }\n    }\n}\n\n","export function Rand(min: number, max: number): number {\n    return (Math.random() * (max - min)) + min;\n}","import { _decorator, Camera, Canvas, Component, EventTouch, geometry, misc, Node, PhysicsSystem, UITransform, Vec2, Vec3, view } from 'cc';\r\nimport { Enemy } from './Enemy';\r\nimport { GameMgr, GameStates } from './GameMgr';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('Gun')\r\nexport class Gun extends Component {\r\n    @property(Node)\r\n    public touchZone: Node = null;\r\n    @property(Node)\r\n    public crosshair: Node = null;\r\n    @property(Node)\r\n    public bulletTrail: Node = null;\r\n    @property(Camera)\r\n    public camera: Camera = null;\r\n    @property(Canvas)\r\n    public canvas: Canvas = null;\r\n\r\n    private rof = (window as any).GameDefines.RATE_OF_FIRE;\r\n    private shootTimeOut = 1 / this.rof;\r\n    private ammo = (window as any).GameDefines.AMMO;\r\n\r\n    private centerX = 0;\r\n    private centerY = 0;\r\n    protected start(): void {\r\n        const canvas = document.getElementById('GameCanvas');\r\n        this.centerX = canvas.width / 2;\r\n        this.centerY = canvas.height / 2;\r\n        console.log(canvas)\r\n    }\r\n\r\n    init() {\r\n        this.ammo = (window as any).GameDefines.AMMO;\r\n    }\r\n\r\n    protected onLoad(): void {\r\n        this.touchZone.on(Node.EventType.TOUCH_MOVE, (event: EventTouch) => {\r\n            if (GameMgr.Instance.GameState !== GameStates.PLAYING) return;\r\n            this.updateGunRotate(event.getDelta());\r\n        })\r\n    }\r\n\r\n    update(dt: number) {\r\n        if (GameMgr.Instance.GameState !== GameStates.PLAYING) {\r\n            this.bulletTrail.active = false;\r\n            return\r\n        } else {\r\n            this.bulletTrail.active = true;\r\n        };\r\n        this.shootTimeOut -= dt;\r\n        if (this.shootTimeOut <= 0) {\r\n            this.shootTimeOut = 1 / this.rof;\r\n            this.shoot();\r\n        }\r\n    }\r\n\r\n    updateGunRotate(delta: Vec2) {\r\n        const newAngleX = this.camera.node.eulerAngles.x + delta.y / 10;\r\n        const newAngleY = this.camera.node.eulerAngles.y - delta.x / 10;\r\n        if (newAngleX > (window as any).GameDefines.MAX_ROTATE_ANGLE || newAngleX < -(window as any).GameDefines.MAX_ROTATE_ANGLE) return;\r\n        if (newAngleY > (window as any).GameDefines.MAX_ROTATE_ANGLE || newAngleY < -(window as any).GameDefines.MAX_ROTATE_ANGLE) return;\r\n        this.camera.node.setRotationFromEuler(new Vec3(newAngleX, newAngleY, 0));\r\n    }\r\n\r\n    shoot() {\r\n        this.ammo -= 1;\r\n        if (this.ammo <= 0) {\r\n            GameMgr.Instance.setState(GameStates.RELOADING);\r\n            return\r\n        };\r\n        let ray = new geometry.Ray();\r\n        this.camera.screenPointToRay(this.centerX, this.centerY, ray);\r\n        // The following parameters are optional\r\n        const mask = 0xffffffff;\r\n        const maxDistance = 10000000;\r\n        const queryTrigger = true;\r\n\r\n        if (PhysicsSystem.instance.raycastClosest(ray, mask, maxDistance, queryTrigger)) {\r\n            const raycastClosestResult = PhysicsSystem.instance.raycastClosestResult;\r\n            const hitPoint = raycastClosestResult.hitPoint\r\n            const hitNormal = raycastClosestResult.hitNormal;\r\n            const collider = raycastClosestResult.collider;\r\n            const distance = raycastClosestResult.distance;\r\n\r\n            const enemy = collider.getComponent(Enemy);\r\n            if (enemy) {\r\n                enemy.hit((window as any).GameDefines.GUN_DAMAGE);\r\n            }\r\n        }\r\n    }\r\n\r\n    reload() {\r\n        this.ammo = (window as any).GameDefines.AMMO;\r\n    }\r\n}\r\n\r\n","import { _decorator, Component, Label, Node } from 'cc';\nimport SingletonComponent from '../core/SingletonComponent';\nimport { EnemyMgr } from './EnemyMgr';\nimport { Gun } from './Gun';\n\nconst { ccclass, property } = _decorator;\n\nif (!(window as any).GameDefines) {\n    (window as any).GameDefines = {\n        RATE_OF_FIRE: 10,\n        GUN_DAMAGE: 1, // Prameter to define the damage of the player\n        AMMO: 50, // Parameter to have a broken gun that stops shooting after X bullets & a clickable warning sign \n        MAX_ROTATE_ANGLE: 30,\n\n        ENEMY_SPAWN_TIME_MIN: 0.25,\n        ENEMY_SPAWN_TIME_MAX: 1,\n        ENEMY_HP: 3, // Parameter to define the damage of the soldiers \n        ENEMY_SPEED: 5, // Speed of soldiers coming down\n        ENEMY_COLOR: { r: 255, g: 255, b: 255 }, // Colors of Soldiers\n        PARACHUTE_COLOR: { r: 255, g: 255, b: 255 }, // Colors of parachutes\n        SCORE_TO_WIN: 20, // Amount of soldiers \n\n        TIMER: 30,\n        EVIRONMENT: 0, // 0: Jungle, 1: Wasteland, 2: Forest - Parameter to choose the environment\n\n        NIGHT_MODE: -1, // -1: off 0: green/black 1: red/black - Parameter to enable night mode\n        VIGNETTE: true, // Parameter to enable camera vignette  to create a tunnel vision look \n        END_CARD: 1, // 0: With stats 1: Second level -Prameter to enable end card with stats or second level endcard with continue CTA \n    }\n}\n\nexport enum GameStates {\n    TUTORIAL,\n    PLAYING,\n    RELOADING,\n    PAUSE,\n    END,\n}\n@ccclass('GameMgr')\nexport class GameMgr extends SingletonComponent<GameMgr>() {\n    @property(Node)\n    public reloadUI: Node = null;\n    @property(Node)\n    public ingameUI: Node = null;\n    @property(Node)\n    public ingame: Node = null;\n    @property(Node)\n    public resultUI: Node = null;\n    @property(Node)\n    public resultUI2: Node = null;\n\n    @property(EnemyMgr)\n    public enemyMgr: EnemyMgr = null;\n    @property(Gun)\n    public gun: Gun = null;\n\n    @property(Label)\n    public scoretxt: Label = null;\n    @property(Label)\n    public timerTxt: Label = null;\n\n    private gameState: GameStates = GameStates.PLAYING;\n    private score: number = 0;\n    private timer = (window as any).GameDefines.TIMER;\n\n    get GameState() {\n        return this.gameState;\n    }\n    get Score() {\n        return this.score;\n    }\n\n    init() {\n        this.score = 0;\n        this.timer = (window as any).GameDefines.TIMER;\n        this.scoretxt.string = `Eliminated: ${this.score}`;\n        this.timerTxt.string = `Time: ${this.timer}s`;\n        this.enemyMgr.init();\n        this.gun.init();\n    }\n\n    onLoad(): void {\n        super.onLoad();\n    }\n\n    setState(state: GameStates) {\n        this.gameState = state;\n        this.reloadUI.active = false;\n\n        switch (state) {\n            case GameStates.PLAYING: {\n                this.ingame.active = true;\n                this.ingameUI.active = true;\n                this.resultUI.active = false;\n                this.resultUI2.active = false;\n                break;\n            }\n            case GameStates.RELOADING: {\n                this.reloadUI.active = true;\n                break;\n            }\n            case GameStates.END: {\n                this.ingame.active = false;\n                this.ingameUI.active = false;\n                if ((window as any).GameDefines.END_CARD === 0) {\n                    this.resultUI.active = true;\n                } else {\n                    this.resultUI2.active = true;\n                }\n                break;\n            }\n            default: break;\n        }\n    }\n\n    protected update(dt: number): void {\n        if (this.GameState === GameStates.PLAYING || this.GameState === GameStates.RELOADING) {\n            this.timer -= dt;\n            this.timerTxt.string = `Time: ${Math.floor(this.timer) + 1}s`;\n\n            if (this.timer <= 0) {\n                this.setState(GameStates.END);\n            }\n        }\n    }\n\n    retry() {\n        if (this.GameState === GameStates.END) {\n            this.setState(GameStates.PLAYING);\n            this.init();\n        }\n    }\n\n    addScore(score) {\n        this.score += score;\n        this.scoretxt.string = `Eliminated: ${this.score}`;\n        if (this.score >= (window as any).GameDefines.SCORE_TO_WIN) {\n            this.setState(GameStates.END);\n        }\n    }\n\n    onProductLink() {\n        window.open('https://www.google.com', 'blank')\n    }\n}\n\n","import { Component } from \"cc\";\r\n\r\nexport default function SingletonComponent<T>() {\r\n  class Singleton extends Component {\r\n    private static instance: T;\r\n\r\n    static get Instance(): T {\r\n      return this.instance;\r\n    }\r\n\r\n    onLoad() {\r\n      if (!Singleton.instance) {\r\n        Singleton.instance = this as unknown as T;\r\n      } else {\r\n        throw `${Singleton.instance.constructor.name} instance already exist`;\r\n      }\r\n    }\r\n  }\r\n\r\n  return Singleton;\r\n}\r\n","import { _decorator, Camera, Color, Component, instantiate, MeshRenderer, Node, ProgressBar, Vec2, Vec3 } from 'cc';\nimport { GameMgr, GameStates } from './GameMgr';\nconst { ccclass, property } = _decorator;\n\n@ccclass('Enemy')\nexport class Enemy extends Component {\n    @property(Number)\n    private speed: number = (window as any).GameDefines.ENEMY_SPEED;\n\n    @property(ProgressBar)\n    private healthBarPrefab: ProgressBar = null;\n\n    @property(Camera)\n    private camera: Camera = null;\n\n    @property(Node)\n    private parachute: Node = null;\n\n    private healthBar: ProgressBar = null;\n\n    private maxHP = (window as any).GameDefines.ENEMY_HP;\n\n    private hp = (window as any).GameDefines.ENEMY_HP;\n    protected onLoad(): void {\n        this.hp = this.maxHP;\n        const newHealthBar = instantiate(this.healthBarPrefab.node);\n        newHealthBar.parent = this.healthBarPrefab.node.parent;\n        this.healthBar = newHealthBar.getComponent(ProgressBar);\n\n        const enemyColor = (window as any).GameDefines.ENEMY_COLOR;\n        this.getComponent(MeshRenderer).material.setProperty('albedo', new Color(enemyColor.r, enemyColor.g, enemyColor.b), 0);\n        const parachuteColor = (window as any).GameDefines.PARACHUTE_COLOR;\n        this.parachute.getComponent(MeshRenderer).material.setProperty('albedo', new Color(parachuteColor.r, parachuteColor.g, parachuteColor.b), 0);\n    }\n\n    update(deltaTime: number) {\n        if (GameMgr.Instance.GameState !== GameStates.PLAYING && GameMgr.Instance.GameState !== GameStates.RELOADING) return;\n\n        if (this.node.position.y <= 0) {\n            this.parachute.active = false;\n        }\n\n        if (this.node.position.z < 45) {\n            this.node.setPosition(\n                this.node.position.x,\n                this.node.position.y > 0 ? this.node.position.y - this.speed * deltaTime : 0,\n                this.node.position.z + (this.node.position.y > 0 ? 0 : this.speed * deltaTime)\n            );\n        } else {\n            GameMgr.Instance.setState(GameStates.END);\n            console.log(this.node.position.z)\n        }\n\n\n        if (this.healthBar) {\n            let healthBarPosition = new Vec3(0, 0, 0);\n            this.camera.convertToUINode(this.node.worldPosition, this.healthBar.node.parent, healthBarPosition);\n            this.healthBar.node.position = healthBarPosition.add3f(0, 50, 0);\n            this.healthBar.node.active = true;\n        }\n    }\n\n    hit(dmg: number) {\n        this.hp -= dmg;\n        this.healthBar.progress = this.hp / this.maxHP;\n        if (this.hp <= 0) {\n            GameMgr.Instance.addScore(1)\n            this.node.destroy();\n        }\n    }\n\n    protected onDestroy(): void {\n        this.healthBar.node.destroy();\n    }\n}\n\n","import { _decorator, Component, Node } from 'cc';\nconst { ccclass, property } = _decorator;\n\n@ccclass('Environments')\nexport class Environments extends Component {\n    onLoad() {\n        this.node.children[(window as any).GameDefines.EVIRONMENT].active = true;\n    }\n}\n\n","import { _decorator, Component, Node } from 'cc';\nconst { ccclass, property } = _decorator;\n\n@ccclass('NightMode')\nexport class NightMode extends Component {\n    onLoad() {\n        if ((window as any).GameDefines.NIGHT_MODE >= 0) {\n            this.node.children[(window as any).GameDefines.NIGHT_MODE].active = true;\n        }\n    }\n}\n\n","import { _decorator, Animation, Component, Node } from 'cc';\nimport { GameMgr, GameStates } from './GameMgr';\nimport { Gun } from './Gun';\nconst { ccclass, property } = _decorator;\n\n@ccclass('ReloadUI')\nexport class ReloadUI extends Component {\n    @property(Gun)\n    public gun: Gun = null;\n    private time = 0;\n    protected onEnable(): void {\n        this.time = 0;\n        this.getComponent(Animation).play();\n    }\n\n    protected onLoad(): void {\n        this.node.on(Node.EventType.TOUCH_END, () => {\n            console.log(this.time)\n            if (this.time > 0.5 && this.time < 1) {\n                this.completeReload();\n            }\n        })\n    }\n\n    update(deltaTime: number) {\n        this.time += deltaTime;\n\n        if (this.time >= 2) {\n            this.completeReload();\n        }\n    }\n\n    completeReload() {\n        this.gun.reload();\n        GameMgr.Instance.setState(GameStates.PLAYING);\n    }\n}\n\n","import { _decorator, Animation, Component, Label, Node } from 'cc';\nimport { GameMgr, GameStates } from './GameMgr';\nimport { Gun } from './Gun';\nconst { ccclass, property } = _decorator;\n\n@ccclass('ResultUI')\nexport class ResultUI extends Component {\n    @property(Label)\n    private scoreTxt: Label = null;\n\n    protected onEnable(): void {\n        this.scoreTxt.string = `Eliminated: ${GameMgr.Instance.Score}`;\n    }\n}\n\n","import { _decorator, Component, Node } from 'cc';\nconst { ccclass, property } = _decorator;\n\n@ccclass('Vignette')\nexport class Vignette extends Component {\n    onLoad() {\n        this.node.active = (window as any).GameDefines.VIGNETTE;\n    }\n}\n\n"]}